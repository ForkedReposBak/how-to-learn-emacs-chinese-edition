
== cc 模式的自定义

我应该带领你了解 Emacs，Emacs Lisp 的关系，和 CC 模式的手册，但是它们是那么的。。。长！
Emacs手册的目录都比我们的前一章 "Unix/c workflow" 要长。
footnote:[ Try this:
lynx --dump http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html |
sed '/^References/,$ d' | wc -w]

然而我会向你展示我是如何尝试去发现我需要的信息在Emacs的源码中的（谢天谢地，大多数都是lisp而不是C）。
我刚才贬低的手册是非常有用的。因为一个开源的项目有这么广泛的文档是非常棒的！
但是一页一页的阅读这些手册是不可能的；你必须学会如何有效的找到正确的信息。
我们已经涉及到了基础的工具，现在我们需要更多的练习。


顺便说一下， c-mode, c++-mode, objc-mode, java-mode，和其他一些名字都是 cc－mode 的别名，
只是需要一些微小的配置修改来支持它们各自的语言。从现在开始我会使用 cc-mode 这个名字。

== 房子编码风格

你喜欢缩进2个，3个，4个，还是8个空格，或者使用 tab？
一个 tab 是多大？无论你喜欢什么样的，我想都不是 cc-mode 默认提供的那样，所以我们可以试试去改变它。


TIP: 访问(打开)一个 C 或者 C++ 文件 (你可以使用 reading/example/rl.c 在前面的章节)

在任何地方按下 TAB 来根据当前的缩进规则达到缩进的位置（要插入一个字面tab，使用 C-q 也称 quoted-insert）

让我们看看 Emacs 在我们按下 TAB 时在后台做了什么:

TIP:
====
C-h k TAB


TAB 运行了命令 c-indent-line-or-region, 这是一个交互的被编译的 Lisp 函数在 `cc-cmds.el` 中.
====

如果你没有看到 cc-cmds.el 的链接, 说明你没有安装 elisp 的源码.
使用你的系统包管理工具去安装 emacs-el 包并再次尝试.

TIP:
====
Follow the link to cc-cmds.el. This will position you right where c-indent-line-or-region is defined. Bring the whole definition into view (C-M-l) if necessary.


[source, elisp]
(defun c-indent-line-or-region (&optional arg region)
  "Indent active region, current line, or block starting on this line.
In Transient Mark mode, when the region is active, reindent the region.
Otherwise, with a prefix argument, rigidly reindent the expression
starting on the current line.
Otherwise reindent just the current line."
  (interactive
   (list current-prefix-arg (use-region-p)))
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))
====

=== Emergency elisp

A brief parenthesis is needed to explain the above code. Let’s start with the if statement at the end:

[source, elisp]
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))

For clarity, let’s simplify it to:

[source, elisp]
  (if region
      a
    b)

If you still don’t understand what that means, pretend that if is actually a function, and that it looks like this:

[source, elisp]
  if(region, a, b)

(Moving that parenthesis to the left of the function is probably the largest single barrier to Lisp’s adoption by the rest of the world.)[2]

TIP: What do the three arguments region, a and b mean? Make a guess, and then check the answer at C-h f if.

The definitions of COND, THEN and ELSE should be pretty clear. But what does it mean by “if is a special form”?

It turns out that if isn’t a regular function. The elisp rule for evaluation of “normal” forms—where “form” means a parenthesized “shape” like (a b c) or (a b (c d))—is to evaluate each argument, and then pass the resulting values to the function.

Let’s consider the function + (elisp doesn’t have special infix operators, so + is just a function). If x is a variable containing the value 5, and y is a variable containing the value 2, then the following two expressions are identical:

[source, elisp]
  (+ x y)
  (+ 5 2)

The function + never sees x; it only sees 5.

TIP: Evaluate the form (+ 5 2): Switch to the *scratch* buffer, type (+ 5 2) on a line of its own, and press C-M-x to evaluate the form and display the result in the echo area.

The very first element in the form (+, in this case) gets evaluated too. + is actually a variable[3] whose value is the function that adds numbers.

Anyway, back to if. if is a “special” form, which means that the elisp interpreter treats if as a special case. Upon reflection, it is obvious that the normal function evaluation rules are not suitable for if: We wouldn’t want to evaluate ELSE, with its possible side-effects, when COND is “true” (non-nil).

All this is explained in the Emacs Lisp manual:

TIP:
====
C-h S if

In the *info* buffer press i (for index) and enter special forms.
====

TIP:
====
Go back to the cc-cmds.el.gz buffer.

Enable the eldoc minor mode (M-x eldoc-mode). Now positioning the point over the if statement will show some brief documentation in the echo area.

Enable show-paren-mode too. This should help clarify where the THEN and ELSE clauses begin and end.
====

Now, back up to the defun:

[source, elisp]
(defun c-indent-line-or-region (&optional arg region)
  "Indent active region, current line, or block starting on this line.
In Transient Mark mode, when the region is active, reindent the region.
Otherwise, with a prefix argument, rigidly reindent the expression
starting on the current line.
Otherwise reindent just the current line."
  (interactive
   (list current-prefix-arg (use-region-p)))
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))

TIP: You now have three ways to get help on defun: eldoc’s summary in the echo area, the reference provided by C-h f, and the more comprehensive Info manual at C-h S. Take your pick.

If you run across the word “lambda”, it’s the same as the “function” keyword in javascript for an anonymous function.

To reiterate:

* defun defines a function named NAME.
* ARGLIST is a list of arguments for the function. In elisp, a list is enclosed in parens: (a b c). In this case it isn’t evaluated as a function call, because defun is a special form that treats this particular list in a special way. When defuning a function that takes no arguments, ARGLIST would be the empty list ().
* The optional DOCSTRING is used by the C-h f help system (yes, even for functions you define yourself!).
* BODY is one or more lists that are evaluated when you call the function.
* …except for the (interactive ...) form.

TIP: C-h S interactive

Don’t get too bogged-down by the explanation; reading the first two paragrahs is enough. Learn to find just the information you need, or you will be easily overwhelmed. Right now we don’t need to know how to use interactive, only what it means.

=== Configuring indentation

So. c-indent-line-or-region is a function that optionally takes arguments arg and region, which, when the function is called interactively (for example by pressing TAB), are set to the prefix argument (if specified with C-u or similar) and “true” if the region is active.

Right now we care about indentation when operating not on the region but on a single line (i.e. region is nil), so let’s look at the ELSE clause:

[source, elisp]
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg))

TIP: Use find-function to jump to the definition of c-indent-command.

This is a long and scary function, but luckily it has a good documentation string. Now that we know the name of this function, we can view the same documentation in a help buffer, with C-h f c-indent-command.

The documentation mentions a couple of interesting variables: c-basic-offset and indent-tabs-mode.

TIP: C-h v c-basic-offset

That talks about “buffer-local” and “file local” variables. What?

TIP: C-h S buffer-local

TIP: From the elisp Info node for Buffer-Local Variables, search for “file local” (you can use C-s or the index i).

As you can see you sometimes have to try different searches to find the right information. “Buffer-local” happened to be in the index, so the symbol search (C-h S) found it; “File local” has a space, but the symbol search doesn’t allow spaces, so you had to search from within the Info buffer itself. You could also have gone up (u) from the “Buffer-Local Variables” Info node and scanned the “Variables” table of contents.

Let’s check the current value of c-basic-offset:

TIP:
====
Switch to buffer rl.c (c-basic-offset is buffer-local, so it matters which buffer we’re in).

M-x eval-expression RET c-basic-offset RET
====

Now change it to 4:

TIP:
====
M-x set-variable c-basic-offset 4

Find a line to re-indent and press TAB.
====

TIP: Repeat the same investigation with variable indent-tabs-mode.

=== Setting variables from elisp code

TIP: Switch to the *scratch* buffer.

Anything starting with a ; is a comment.

TIP: Type in this form and evaluate it with C-M-x: (set indent-tabs-mode nil)

You triggered an error, and Emacs brings up the backtrace in an elisp debugger. You tried to set a constant to nil, which is clearly an error.

TIP: Explain why this happened, with your knowledge of the previous value of indent-tabs-mode and of the elisp rules for evaluating functions.

We can quote the name of the variable so that it doesn’t get evaluated:

TIP: (set 'indent-tabs-mode nil)

Read more about quoting:

TIP:
====
C-h S quote

C-h S setq
====

The following forms do exactly the same; the preferred form is setq.

[source, elisp]
(set 'indent-tabs-mode nil)
(set (quote indent-tabs-mode) nil)
(setq indent-tabs-mode nil)

One last thing: indent-tabs-mode is buffer-local, so setting it here only affects the *scratch* buffer. To make the change global, you must use setq-default.

=== Init file

Your changes to these variables will be lost when you restart Emacs. You need to put your settings into an initialization file that Emacs will load each time it starts.

TIP: In the Emacs manual (C-h r) table of contents, search for “init file” and read the first paragraph.

There are several places you can put your init file; I suggest the one that goes inside the ~/.emacs.d directory, so you can organize your customizations by keeping multiple elisp files in the same directory, and loading them from the main init file. Put this directory under version control.

TIP: Visit (open) the init file you’ve chosen (if the file doesn’t exist, Emacs will create it when you save the buffer).

TIP:
====
Add the following lines:

(setq-default c-basic-offset 4)
(setq-default indent-tabs-mode nil)

====

(or whatever values you have chosen).

TIP: Restart Emacs, visit rl.c, and verify that your settings are in effect.

=== 钩子

默认情况下，cc 模式会自动重新缩进行当你输入一个字符比如 ; 或者 } 时。
这些被成为 “electric characters” 不过你可以禁用这个行为在一个特定的缓冲罐你去中
使用  c-toggle-electric-state (C-c C-l)。

想要总是禁用 electric characters 我们可以让 Emacs 每次加载 cc 模式时
调用 c-toggle-electric-state。

TIP: C-h m （从 rl.c 缓冲区， 或任何其他 cc 模式的缓冲区）来找出 cc 模式提供的钩子的名字。

一个钩子是一个变量包含一个要去运行的函数的列表，通常是一个特定编辑模式的入口。
对于 C 语言的代码我们有两个钩子：一个是所有被 cc 模式支持的语言，另一个仅仅对于 C 语言。
我们将会使用第一个， c-mode-common-hook。

TIP:
====
Add the following to your init file:

[source, elisp]
(defun my-disable-electric-indentation ()
  "Stop ';', '}', etc. from re-indenting the current line."
  (c-toggle-electric-state -1))
(add-hook 'c-mode-common-hook 'my-disable-electric-indentation)
====

首先我们定义了一个无参函数并且调用 (c-toggle-electric-state -1)。
然后我们加入这个函数到 c-mode-common-hook 。

参数 -1 告诉  c-toggle-electric-state 被禁用了，而不是被 electric behavior 所触发
（我是从 C-h f c-toggle-electric-state 中学到的；有些函数想要 nil，但是这个要的是一个负数 ）。

你可以直接给一个钩子加入一个匿名函数：

[source, elisp]
(add-hook 'c-mode-common-hook
          (lambda () (c-toggle-electric-state -1)))

但是之后你就没有办法通过名字在引用这个函数了， 所以你不能使用 remove-hook 来把它从钩子中移除了。

=== cc 模式的风格系统

说起代码风格，可不只是缩进的尺寸那么简单。
左花括号放在哪里？他们也需要被缩进吗？

c-basic-offset 的 C-h v documentation 提到了一个 『风格系统』，
并且指引我们到 c-default-style 。

TIP:
====
C-h v c-default-style
[source, elisp]
c-default-style is a variable defined in `cc-vars.el'.
Its value is ((java-mode . "java")
 (awk-mode . "awk")
 (other . "gnu"))
====

Elisp 语法对于一个 list 是 (a b c)， 对一个 pair 是 (a . b)。
Pairs 被称作 “cons cells” 在 lisp 术语中，
并且你可以使用函数 car 来获取第一个元素，
函数 cdr （发音 “could-er”） 来获取第二个。

所以 c-default-style 的值是一个包含了 3 个 pair 的列表；
着就像 java 模式中的查询字典，awk-mode 和其他是 键，"java", "awk" 和 "gnu" 是 值
（这里，每个编辑模式的风格名字被 建 所代表了）。
这些查找字典被称为 “alists”。

TIP: C-h S alist

In your init file you could set c-default-style so that the default style for other[4] is something other than "gnu".

If you need to customize anything (including c-basic-offset and indent-tabs-mode) to something different than any of the built-in styles, I recommend you define your own style: Thus if you work on different projects with different styles, you will be able to switch easily (with c-set-style). The way we set c-basic-offset earlier will automatically create a style called “user”.

For help see “Configuration basics”, “Customizing indentation”, and “Sample .emacs file” in the CC Mode Manual.

=== 绑定按键

我常常在不同的源代码之间有的文件需要一个 8 个空格长的 tab，另一个在同目录的文件下
甚至同一文件的不同行，需要一个 4 个空格长的 tab。
让我们创建一个函数来在 tab 宽度在 2，4，8 个空格之间循环。

（我发现变量 tab-width 通过使用 apropos-variable 来搜索 “tab”.）

TIP:
====
[source, elisp]
(defun my-tab-width ()
  "Cycle tab-width between values 2, 4, and 8."
  (interactive)
  (setq tab-width
        (cond ((eq tab-width 8) 2)
              ((eq tab-width 2) 4)
              (t 8)))
  (redraw-display))
====

这个条件表达式等于 2 如果 tab-width 等于 8；
变为 4 如果 tab-width 等于 2；否则就是 8.
在 Info 手册中查找 cond 和 eq 如果你喜欢。

我把搜索我写的函数命名为 “my-something”， 因为 elisp 没有单独的命名空间
为每个模式或包；通过这种方法我可以确保我的函数不会意外的被某个编辑模式所依赖的
一个已经存在的函数所覆盖。

现在让我们绑定新的函数到一个按键序列，这样我们就能方便的调用它了。
C-c 跟随一个字母就是用来让用户去定义的，那我们就使用 C-c t：

TIP:
====
[source, elisp]
(global-set-key (kbd "C-c t") 'my-tab-width)
====

其中 global-set-key 中 “global” 的意味很明显了。
如果喜欢一个只在 cc-mode 有用的按键绑定， 使用 define-key 来添加
绑定到这个模式的 keymap：


[source, elisp]
(define-key c-mode-base-map (kbd "C-c t") 'my-tab-width)

我发现 c-mode-base-map 使用 C-h v c-mode- TAB TAB.
也有一个 c-mode-map 仅仅用于 C 语言，而不是所有被 cc 模式支持的语言。

=== 关联文件扩展名和一个编辑模式

假设你想要 .h 文件被打开时使用 c++ 模式而不是 c 模式:

TIP:
====
C-h v auto-mode-alist

C-h f add-to-list
====

The trickiest part will be getting the regular expression
right—elisp doesn’t have syntax for a regexp literal,
so you have to put it inside a string,
and then the string backslash-escaping
makes the regexp rather awful. See “Regexps” in the Emacs manual.

=== Homework

如果你有 30 分钟时间, 阅读 Steve Yegge 的 Emergency Elisp.

如果你有 6 个月的时间来完成计算机程序的结构与解释, 一个 MIT 的有名的课本教授了重要的(也很先进)的编程概念和技术使用一个简单的 Lisp 方言叫做 Scheme.
如果你喜欢数学方面的东西比如用埃拉托斯特尼筛法来找出素数, 海伦的方法来计算平方根, 或者蒙特卡罗模拟法来估算 pi 值, 那你会爱上这本书的.

如果你在阅读本手册之前在网上有一大堆的 .emacs 自定义配置, 试着去彻底的理解它们.

将来, 当你需要一个特定的自定义选项, 试着去发现解决方案从手册或者 elisp 的源码在用谷歌搜索之前.

不要尝试去修改 Emacs 发行版自带的 elisp 文件.
第一, 要合并你的改变到一个新的 Emacs 版本并不容易.
第二, 文件是被编译过的, 所以你需要重新编译它们.
第三, 就算你这样做了也没什么用因为核心的 elisp 函数都是被内置在 Emacs 的镜像中的,
所以你不得不重新编译整个程序.
你应该做的, 是使用变量和钩子来提供自定义配置.

不要把注意力放在 Emacs 的手册上当它告诉你去使用 'Easy customization' 这个功能时(在一些帮助缓冲区中它会说“you can customize this variable”).
它指向一个非常糟糕的半图形化界面来设置 Emacs 的变量. 最好保持你所有的自定义配置在你的 init 文件中.
