
== cc 模式的自定义

我应该带领你了解 Emacs，Emacs Lisp 的关系，和 CC 模式的手册，但是它们是那么的。。。长！
Emacs手册的目录都比我们的前一章 "Unix/c workflow" 要长。
footnote:[ Try this:
lynx --dump http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html |
sed '/^References/,$ d' | wc -w]

然而我会向你展示我是如何尝试去发现我需要的信息在Emacs的源码中的（谢天谢地，大多数都是lisp而不是C）。
我刚才贬低的手册是非常有用的。因为一个开源的项目有这么广泛的文档是非常棒的！
但是一页一页的阅读这些手册是不可能的；你必须学会如何有效的找到正确的信息。
我们已经涉及到了基础的工具，现在我们需要更多的练习。


顺便说一下， c-mode, c++-mode, objc-mode, java-mode，和其他一些名字都是 cc－mode 的别名，
只是需要一些微小的配置修改来支持它们各自的语言。从现在开始我会使用 cc-mode 这个名字。

== 房子编码风格

你喜欢缩进2个，3个，4个，还是8个空格，或者使用 tab？
一个 tab 是多大？无论你喜欢什么样的，我想都不是 cc-mode 默认提供的那样，所以我们可以试试去改变它。


TIP: 访问(打开)一个 C 或者 C++ 文件 (你可以使用 reading/example/rl.c 在前面的章节)

在任何地方按下 TAB 来根据当前的缩进规则达到缩进的位置（要插入一个字面tab，使用 C-q 也称 quoted-insert）

让我们看看 Emacs 在我们按下 TAB 时在后台做了什么:

TIP:
====
C-h k TAB


TAB 运行了命令 c-indent-line-or-region, 这是一个交互的被编译的 Lisp 函数在 `cc-cmds.el` 中.
====

如果你没有看到 cc-cmds.el 的链接, 说明你没有安装 elisp 的源码.
使用你的系统包管理工具去安装 emacs-el 包并再次尝试.

TIP:
====

跟随 cc-cmds.el 的链接. 这会把你定位到 c-indent-line-or-region 被定义的地方.
如果有必要, 把整个定义带到视图中 (C-M-l).

[source, elisp]
(defun c-indent-line-or-region (&optional arg region)
  "Indent active region, current line, or block starting on this line.
In Transient Mark mode, when the region is active, reindent the region.
Otherwise, with a prefix argument, rigidly reindent the expression
starting on the current line.
Otherwise reindent just the current line."
  (interactive
   (list current-prefix-arg (use-region-p)))
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))
====

=== Emergency elisp

关于上面的代码有一句题外话需要解释一下. 让我们从结尾处的 if 条件开始:

[source, elisp]
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))

让我们把它简化一下:

[source, elisp]
  (if region
      a
    b)

如果你还是不知道这意味着什么, 就当它是一个函数吧, 然后它看上去就像这样:

[source, elisp]
  if(region, a, b)

移动圆括号到函数的左边大概是 Lisp 被世界接受的最大的障碍.[2]

TIP: 参数部分的 a 和 b 是什么意思? 猜猜看, 可以用 C-h f if 来查看答案.

COND, THEN 和 ELSE 的定义是非常清楚的. 但是 “if is a special form” 是什么意思?

It turns out that if isn’t a regular function.
The elisp rule for evaluation of “normal” forms—where “form” means a parenthesized “shape”
 like (a b c) or (a b (c d))—is to evaluate each argument,
 and then pass the resulting values to the function.
这会证明它是否是一个常规的函数. elisp 对于股

让我们假设函数 + (elisp 没有特殊操作符, 所以 + 只是一个函数而已). 如果 x 是一个变量包含值 5, 而 y 是一个变量包含值 2,
那么下面的两个表达式是等同的.

[source, elisp]
  (+ x y)
  (+ 5 2)

函数 + 看不懂 x, 它只看到 5.

TIP: 对表达式 (+ 5 2) 求值: 切换到 *scratch* 缓冲区, 输入 (+ 5 2) 在它自己的一行中, 然后按下 C-M-x 来求值表达式并且显示结果在 echo area 中.

在表达式的第一个元素 (这里指 +) 也被求值了. + 实际上是一个变量, 它的值就是给数字做加法的函数.

Anyway, back to if. if is a “special” form, which means that the elisp interpreter treats if as a special case. Upon reflection, it is obvious that the normal function evaluation rules are not suitable for if: We wouldn’t want to evaluate ELSE, with its possible side-effects, when COND is “true” (non-nil).
好了, 回到 if. if 是一个 "特殊" 的表达式, 它的意思是 elisp 的解释器会把 if 当做一种特殊的情况. 考虑一下, 很明显普通的函数求值规则不适合它: 我们不会想要去求值 ELSE,
和它的特殊副作用, 当 COND 是 "true" 是( non-nil ).

这些都再 Emacs Lisp 的手册里有解释:

TIP:
====
C-h S if

In the *info* buffer press i (for index) and enter special forms.
====

TIP:
====
Go back to the cc-cmds.el.gz buffer.

Enable the eldoc minor mode (M-x eldoc-mode). Now positioning the point over the if statement will show some brief documentation in the echo area.

Enable show-paren-mode too. This should help clarify where the THEN and ELSE clauses begin and end.
====

Now, back up to the defun:

[source, elisp]
(defun c-indent-line-or-region (&optional arg region)
  "Indent active region, current line, or block starting on this line.
In Transient Mark mode, when the region is active, reindent the region.
Otherwise, with a prefix argument, rigidly reindent the expression
starting on the current line.
Otherwise reindent just the current line."
  (interactive
   (list current-prefix-arg (use-region-p)))
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))

TIP: 你有三种方法在 defun 上获得帮助: eldoc’s summary in the echo area, the reference provided by C-h f, and the more comprehensive Info manual at C-h S. Take your pick.

If you run across the word “lambda”, it’s the same as the “function” keyword in javascript for an anonymous function.

To reiterate:

* defun defines a function named NAME.
* ARGLIST is a list of arguments for the function. In elisp, a list is enclosed in parens: (a b c). In this case it isn’t evaluated as a function call, because defun is a special form that treats this particular list in a special way. When defuning a function that takes no arguments, ARGLIST would be the empty list ().
* The optional DOCSTRING is used by the C-h f help system (yes, even for functions you define yourself!).
* BODY is one or more lists that are evaluated when you call the function.
* …except for the (interactive ...) form.

TIP: C-h S interactive

Don’t get too bogged-down by the explanation; reading the first two paragrahs is enough. Learn to find just the information you need, or you will be easily overwhelmed. Right now we don’t need to know how to use interactive, only what it means.

=== Configuring indentation

So. c-indent-line-or-region is a function that optionally takes arguments arg and region, which, when the function is called interactively (for example by pressing TAB), are set to the prefix argument (if specified with C-u or similar) and “true” if the region is active.

Right now we care about indentation when operating not on the region but on a single line (i.e. region is nil), so let’s look at the ELSE clause:

[source, elisp]
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg))

TIP: Use find-function to jump to the definition of c-indent-command.

This is a long and scary function, but luckily it has a good documentation string. Now that we know the name of this function, we can view the same documentation in a help buffer, with C-h f c-indent-command.

The documentation mentions a couple of interesting variables: c-basic-offset and indent-tabs-mode.

TIP: C-h v c-basic-offset

That talks about “buffer-local” and “file local” variables. What?

TIP: C-h S buffer-local

TIP: From the elisp Info node for Buffer-Local Variables, search for “file local” (you can use C-s or the index i).

As you can see you sometimes have to try different searches to find the right information. “Buffer-local” happened to be in the index, so the symbol search (C-h S) found it; “File local” has a space, but the symbol search doesn’t allow spaces, so you had to search from within the Info buffer itself. You could also have gone up (u) from the “Buffer-Local Variables” Info node and scanned the “Variables” table of contents.

Let’s check the current value of c-basic-offset:

TIP:
====
Switch to buffer rl.c (c-basic-offset is buffer-local, so it matters which buffer we’re in).

M-x eval-expression RET c-basic-offset RET
====

Now change it to 4:

TIP:
====
M-x set-variable c-basic-offset 4

Find a line to re-indent and press TAB.
====

TIP: Repeat the same investigation with variable indent-tabs-mode.

=== Setting variables from elisp code

TIP: Switch to the *scratch* buffer.

Anything starting with a ; is a comment.

TIP: Type in this form and evaluate it with C-M-x: (set indent-tabs-mode nil)

You triggered an error, and Emacs brings up the backtrace in an elisp debugger. You tried to set a constant to nil, which is clearly an error.

TIP: Explain why this happened, with your knowledge of the previous value of indent-tabs-mode and of the elisp rules for evaluating functions.

We can quote the name of the variable so that it doesn’t get evaluated:

TIP: (set 'indent-tabs-mode nil)

Read more about quoting:

TIP:
====
C-h S quote

C-h S setq
====

The following forms do exactly the same; the preferred form is setq.

[source, elisp]
(set 'indent-tabs-mode nil)
(set (quote indent-tabs-mode) nil)
(setq indent-tabs-mode nil)

One last thing: indent-tabs-mode is buffer-local, so setting it here only affects the *scratch* buffer. To make the change global, you must use setq-default.

=== Init file

Your changes to these variables will be lost when you restart Emacs. You need to put your settings into an initialization file that Emacs will load each time it starts.

TIP: In the Emacs manual (C-h r) table of contents, search for “init file” and read the first paragraph.

There are several places you can put your init file; I suggest the one that goes inside the ~/.emacs.d directory, so you can organize your customizations by keeping multiple elisp files in the same directory, and loading them from the main init file. Put this directory under version control.

TIP: Visit (open) the init file you’ve chosen (if the file doesn’t exist, Emacs will create it when you save the buffer).

TIP:
====
Add the following lines:

(setq-default c-basic-offset 4)
(setq-default indent-tabs-mode nil)

====

(or whatever values you have chosen).

TIP: Restart Emacs, visit rl.c, and verify that your settings are in effect.

=== 钩子

默认情况下，cc 模式会自动重新缩进行当你输入一个字符比如 ; 或者 } 时。
这些被成为 “electric characters” 不过你可以禁用这个行为在一个特定的缓冲罐你去中
使用  c-toggle-electric-state (C-c C-l)。

想要总是禁用 electric characters 我们可以让 Emacs 每次加载 cc 模式时
调用 c-toggle-electric-state。

TIP: C-h m （从 rl.c 缓冲区， 或任何其他 cc 模式的缓冲区）来找出 cc 模式提供的钩子的名字。

一个钩子是一个变量包含一个要去运行的函数的列表，通常是一个特定编辑模式的入口。
对于 C 语言的代码我们有两个钩子：一个是所有被 cc 模式支持的语言，另一个仅仅对于 C 语言。
我们将会使用第一个， c-mode-common-hook。

TIP:
====
Add the following to your init file:

[source, elisp]
(defun my-disable-electric-indentation ()
  "Stop ';', '}', etc. from re-indenting the current line."
  (c-toggle-electric-state -1))
(add-hook 'c-mode-common-hook 'my-disable-electric-indentation)
====

首先我们定义了一个无参函数并且调用 (c-toggle-electric-state -1)。
然后我们加入这个函数到 c-mode-common-hook 。

参数 -1 告诉  c-toggle-electric-state 被禁用了，而不是被 electric behavior 所触发
（我是从 C-h f c-toggle-electric-state 中学到的；有些函数想要 nil，但是这个要的是一个负数 ）。

你可以直接给一个钩子加入一个匿名函数：

[source, elisp]
(add-hook 'c-mode-common-hook
          (lambda () (c-toggle-electric-state -1)))

但是之后你就没有办法通过名字在引用这个函数了， 所以你不能使用 remove-hook 来把它从钩子中移除了。

=== cc 模式的风格系统

说起代码风格，可不只是缩进的尺寸那么简单。
左花括号放在哪里？他们也需要被缩进吗？

c-basic-offset 的 C-h v documentation 提到了一个 『风格系统』，
并且指引我们到 c-default-style 。

TIP:
====
C-h v c-default-style
[source, elisp]
c-default-style is a variable defined in `cc-vars.el'.
Its value is ((java-mode . "java")
 (awk-mode . "awk")
 (other . "gnu"))
====

Elisp 语法对于一个 list 是 (a b c)， 对一个 pair 是 (a . b)。
Pairs 被称作 “cons cells” 在 lisp 术语中，
并且你可以使用函数 car 来获取第一个元素，
函数 cdr （发音 “could-er”） 来获取第二个。

所以 c-default-style 的值是一个包含了 3 个 pair 的列表；
着就像 java 模式中的查询字典，awk-mode 和其他是 键，"java", "awk" 和 "gnu" 是 值
（这里，每个编辑模式的风格名字被 建 所代表了）。
这些查找字典被称为 “alists”。

TIP: C-h S alist

在你的初始化文件中你可以设置 c-default-style 这样默认的风格对于其它就不是 "gnu" 了.

如果你需要自定义任何不在内建的风格内的东西(包含 c-basic-offset 和 indent-tabs-mode),
我推荐你定义你自己的风格: 这样如果你在不同的项目中使用不同的分割, 你就能很方便的切换(使用 c-set-style).
我们先前设置 c-basic-offset 的方式会自动创建一个叫做 "user" 的风格.

要获取帮助请查看  “Configuration basics”, “Customizing indentation”, 和 “Sample .emacs file” 在 CC 模式手册中.

=== 绑定按键

我常常在不同的源代码之间有的文件需要一个 8 个空格长的 tab，另一个在同目录的文件下
甚至同一文件的不同行，需要一个 4 个空格长的 tab。
让我们创建一个函数来在 tab 宽度在 2，4，8 个空格之间循环。

（我发现变量 tab-width 通过使用 apropos-variable 来搜索 “tab”.）

TIP:
====
[source, elisp]
(defun my-tab-width ()
  "Cycle tab-width between values 2, 4, and 8."
  (interactive)
  (setq tab-width
        (cond ((eq tab-width 8) 2)
              ((eq tab-width 2) 4)
              (t 8)))
  (redraw-display))
====

这个条件表达式等于 2 如果 tab-width 等于 8；
变为 4 如果 tab-width 等于 2；否则就是 8.
在 Info 手册中查找 cond 和 eq 如果你喜欢。

我把搜索我写的函数命名为 “my-something”， 因为 elisp 没有单独的命名空间
为每个模式或包；通过这种方法我可以确保我的函数不会意外的被某个编辑模式所依赖的
一个已经存在的函数所覆盖。

现在让我们绑定新的函数到一个按键序列，这样我们就能方便的调用它了。
C-c 跟随一个字母就是用来让用户去定义的，那我们就使用 C-c t：

TIP:
====
[source, elisp]
(global-set-key (kbd "C-c t") 'my-tab-width)
====

其中 global-set-key 中 “global” 的意味很明显了。
如果喜欢一个只在 cc-mode 有用的按键绑定， 使用 define-key 来添加
绑定到这个模式的 keymap：


[source, elisp]
(define-key c-mode-base-map (kbd "C-c t") 'my-tab-width)

我发现 c-mode-base-map 使用 C-h v c-mode- TAB TAB.
也有一个 c-mode-map 仅仅用于 C 语言，而不是所有被 cc 模式支持的语言。

=== 关联文件扩展名和一个编辑模式

假设你想要 .h 文件被打开时使用 c++ 模式而不是 c 模式:

TIP:
====
C-h v auto-mode-alist

C-h f add-to-list
====

The trickiest part will be getting the regular expression
right—elisp doesn’t have syntax for a regexp literal,
so you have to put it inside a string,
and then the string backslash-escaping
makes the regexp rather awful. See “Regexps” in the Emacs manual.

=== Homework

如果你有 30 分钟时间, 阅读 Steve Yegge 的 Emergency Elisp.

如果你有 6 个月的时间来完成计算机程序的结构与解释, 一个 MIT 的有名的课本教授了重要的(也很先进)的编程概念和技术使用一个简单的 Lisp 方言叫做 Scheme.
如果你喜欢数学方面的东西比如用埃拉托斯特尼筛法来找出素数, 海伦的方法来计算平方根, 或者蒙特卡罗模拟法来估算 pi 值, 那你会爱上这本书的.

如果你在阅读本手册之前在网上有一大堆的 .emacs 自定义配置, 试着去彻底的理解它们.

将来, 当你需要一个特定的自定义选项, 试着去发现解决方案从手册或者 elisp 的源码在用谷歌搜索之前.

不要尝试去修改 Emacs 发行版自带的 elisp 文件.
第一, 要合并你的改变到一个新的 Emacs 版本并不容易.
第二, 文件是被编译过的, 所以你需要重新编译它们.
第三, 就算你这样做了也没什么用因为核心的 elisp 函数都是被内置在 Emacs 的镜像中的,
所以你不得不重新编译整个程序.
你应该做的, 是使用变量和钩子来提供自定义配置.

不要把注意力放在 Emacs 的手册上当它告诉你去使用 'Easy customization' 这个功能时(在一些帮助缓冲区中它会说“you can customize this variable”).
它指向一个非常糟糕的半图形化界面来设置 Emacs 的变量. 最好保持你所有的自定义配置在你的 init 文件中.
