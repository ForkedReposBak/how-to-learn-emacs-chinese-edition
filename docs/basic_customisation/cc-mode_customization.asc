
== cc 模式的自定义

我应该带领你了解 Emacs，Emacs Lisp 的关系，和 CC 模式的手册，但是它们是那么的。。。长！
Emacs手册的目录都比我们的前一章 "Unix/c workflow" 要长。
footnote:[ Try this:
lynx --dump http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html |
sed '/^References/,$ d' | wc -w]

然而我会向你展示我是如何尝试去发现我需要的信息在Emacs的源码中的（谢天谢地，大多数都是lisp而不是C）。
我刚才贬低的手册是非常有用的。因为一个开源的项目有这么广泛的文档是非常棒的！
但是一页一页的阅读这些手册是不可能的；你必须学会如何有效的找到正确的信息。
我们已经涉及到了基础的工具，现在我们需要更多的练习。


顺便说一下， c-mode, c++-mode, objc-mode, java-mode，和其他一些名字都是 cc－mode 的别名，
只是需要一些微小的配置修改来支持它们各自的语言。从现在开始我会使用 cc-mode 这个名字。

== 房子编码风格

你喜欢缩进2个，3个，4个，还是8个空格，或者使用 tab？
一个 tab 是多大？无论你喜欢什么样的，我想都不是 cc-mode 默认提供的那样，所以我们可以试试去改变它。


TIP: 访问(打开)一个 C 或者 C++ 文件 (你可以使用 reading/example/rl.c 在前面的章节)

在任何地方按下 TAB 来根据当前的缩进规则达到缩进的位置（要插入一个字面tab，使用 C-q 也称 quoted-insert）

让我们看看 Emacs 在我们按下 TAB 时在后台做了什么:

TIP:
====
C-h k TAB


TAB 运行了命令 c-indent-line-or-region, 这是一个交互的被编译的 Lisp 函数在 `cc-cmds.el` 中.
====

如果你没有看到 cc-cmds.el 的链接, 说明你没有安装 elisp 的源码.
使用你的系统包管理工具去安装 emacs-el 包并再次尝试.

TIP:
====
Follow the link to cc-cmds.el. This will position you right where c-indent-line-or-region is defined. Bring the whole definition into view (C-M-l) if necessary.


[source, elisp]
(defun c-indent-line-or-region (&optional arg region)
  "Indent active region, current line, or block starting on this line.
In Transient Mark mode, when the region is active, reindent the region.
Otherwise, with a prefix argument, rigidly reindent the expression
starting on the current line.
Otherwise reindent just the current line."
  (interactive
   (list current-prefix-arg (use-region-p)))
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))
====

=== Emergency elisp

A brief parenthesis is needed to explain the above code. Let’s start with the if statement at the end:

[source, elisp]
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))

For clarity, let’s simplify it to:

[source, elisp]
  (if region
      a
    b)

If you still don’t understand what that means, pretend that if is actually a function, and that it looks like this:

[source, elisp]
  if(region, a, b)

(Moving that parenthesis to the left of the function is probably the largest single barrier to Lisp’s adoption by the rest of the world.)[2]

TIP: What do the three arguments region, a and b mean? Make a guess, and then check the answer at C-h f if.

The definitions of COND, THEN and ELSE should be pretty clear. But what does it mean by “if is a special form”?

It turns out that if isn’t a regular function. The elisp rule for evaluation of “normal” forms—where “form” means a parenthesized “shape” like (a b c) or (a b (c d))—is to evaluate each argument, and then pass the resulting values to the function.

Let’s consider the function + (elisp doesn’t have special infix operators, so + is just a function). If x is a variable containing the value 5, and y is a variable containing the value 2, then the following two expressions are identical:

[source, elisp]
  (+ x y)
  (+ 5 2)

The function + never sees x; it only sees 5.

TIP: Evaluate the form (+ 5 2): Switch to the *scratch* buffer, type (+ 5 2) on a line of its own, and press C-M-x to evaluate the form and display the result in the echo area.

The very first element in the form (+, in this case) gets evaluated too. + is actually a variable[3] whose value is the function that adds numbers.

Anyway, back to if. if is a “special” form, which means that the elisp interpreter treats if as a special case. Upon reflection, it is obvious that the normal function evaluation rules are not suitable for if: We wouldn’t want to evaluate ELSE, with its possible side-effects, when COND is “true” (non-nil).

All this is explained in the Emacs Lisp manual:

TIP:
====
C-h S if

In the *info* buffer press i (for index) and enter special forms.
====

TIP:
====
Go back to the cc-cmds.el.gz buffer.

Enable the eldoc minor mode (M-x eldoc-mode). Now positioning the point over the if statement will show some brief documentation in the echo area.

Enable show-paren-mode too. This should help clarify where the THEN and ELSE clauses begin and end.
====

Now, back up to the defun:

[source, elisp]
(defun c-indent-line-or-region (&optional arg region)
  "Indent active region, current line, or block starting on this line.
In Transient Mark mode, when the region is active, reindent the region.
Otherwise, with a prefix argument, rigidly reindent the expression
starting on the current line.
Otherwise reindent just the current line."
  (interactive
   (list current-prefix-arg (use-region-p)))
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg)))

TIP: You now have three ways to get help on defun: eldoc’s summary in the echo area, the reference provided by C-h f, and the more comprehensive Info manual at C-h S. Take your pick.

If you run across the word “lambda”, it’s the same as the “function” keyword in javascript for an anonymous function.

To reiterate:

* defun defines a function named NAME.
* ARGLIST is a list of arguments for the function. In elisp, a list is enclosed in parens: (a b c). In this case it isn’t evaluated as a function call, because defun is a special form that treats this particular list in a special way. When defuning a function that takes no arguments, ARGLIST would be the empty list ().
* The optional DOCSTRING is used by the C-h f help system (yes, even for functions you define yourself!).
* BODY is one or more lists that are evaluated when you call the function.
* …except for the (interactive ...) form.

TIP: C-h S interactive

Don’t get too bogged-down by the explanation; reading the first two paragrahs is enough. Learn to find just the information you need, or you will be easily overwhelmed. Right now we don’t need to know how to use interactive, only what it means.

=== Configuring indentation

So. c-indent-line-or-region is a function that optionally takes arguments arg and region, which, when the function is called interactively (for example by pressing TAB), are set to the prefix argument (if specified with C-u or similar) and “true” if the region is active.

Right now we care about indentation when operating not on the region but on a single line (i.e. region is nil), so let’s look at the ELSE clause:

[source, elisp]
  (if region
      (c-indent-region (region-beginning) (region-end))
    (c-indent-command arg))

TIP: Use find-function to jump to the definition of c-indent-command.

This is a long and scary function, but luckily it has a good documentation string. Now that we know the name of this function, we can view the same documentation in a help buffer, with C-h f c-indent-command.

The documentation mentions a couple of interesting variables: c-basic-offset and indent-tabs-mode.

TIP: C-h v c-basic-offset

That talks about “buffer-local” and “file local” variables. What?

TIP: C-h S buffer-local

TIP: From the elisp Info node for Buffer-Local Variables, search for “file local” (you can use C-s or the index i).

As you can see you sometimes have to try different searches to find the right information. “Buffer-local” happened to be in the index, so the symbol search (C-h S) found it; “File local” has a space, but the symbol search doesn’t allow spaces, so you had to search from within the Info buffer itself. You could also have gone up (u) from the “Buffer-Local Variables” Info node and scanned the “Variables” table of contents.

Let’s check the current value of c-basic-offset:

TIP:
====
Switch to buffer rl.c (c-basic-offset is buffer-local, so it matters which buffer we’re in).

M-x eval-expression RET c-basic-offset RET
====

Now change it to 4:

TIP:
====
M-x set-variable c-basic-offset 4

Find a line to re-indent and press TAB.
====

TIP: Repeat the same investigation with variable indent-tabs-mode.

=== Setting variables from elisp code

TIP: Switch to the *scratch* buffer.

Anything starting with a ; is a comment.

TIP: Type in this form and evaluate it with C-M-x: (set indent-tabs-mode nil)

You triggered an error, and Emacs brings up the backtrace in an elisp debugger. You tried to set a constant to nil, which is clearly an error.

TIP: Explain why this happened, with your knowledge of the previous value of indent-tabs-mode and of the elisp rules for evaluating functions.

We can quote the name of the variable so that it doesn’t get evaluated:

TIP: (set 'indent-tabs-mode nil)

Read more about quoting:

TIP:
====
C-h S quote

C-h S setq
====

The following forms do exactly the same; the preferred form is setq.

[source, elisp]
(set 'indent-tabs-mode nil)
(set (quote indent-tabs-mode) nil)
(setq indent-tabs-mode nil)

One last thing: indent-tabs-mode is buffer-local, so setting it here only affects the *scratch* buffer. To make the change global, you must use setq-default.

=== Init file

Your changes to these variables will be lost when you restart Emacs. You need to put your settings into an initialization file that Emacs will load each time it starts.

TIP: In the Emacs manual (C-h r) table of contents, search for “init file” and read the first paragraph.

There are several places you can put your init file; I suggest the one that goes inside the ~/.emacs.d directory, so you can organize your customizations by keeping multiple elisp files in the same directory, and loading them from the main init file. Put this directory under version control.

TIP: Visit (open) the init file you’ve chosen (if the file doesn’t exist, Emacs will create it when you save the buffer).

TIP:
====
Add the following lines:

(setq-default c-basic-offset 4)
(setq-default indent-tabs-mode nil)

====

(or whatever values you have chosen).

TIP: Restart Emacs, visit rl.c, and verify that your settings are in effect.

=== Hooks

By default, cc-mode automatically re-indents the line whenever you type a character like ; or }. These are called “electric characters” and you can disable this behavior in a particular buffer with c-toggle-electric-state (C-c C-l).

To always disable electric characters we can have Emacs call c-toggle-electric-state each time it loads cc-mode.

TIP: C-h m (from the rl.c buffer, or any other cc-mode buffer) to find out the names of the hooks provided by cc-mode.

A hook is a variable containing a list of functions to be run, usually upon entry to a particular editing mode. For C code we have two hooks: One for all of cc-mode’s supported languages, and one just for C. We’ll use the first one, c-mode-common-hook.

TIP:
====
Add the following to your init file:

[source, elisp]
(defun my-disable-electric-indentation ()
  "Stop ';', '}', etc. from re-indenting the current line."
  (c-toggle-electric-state -1))
(add-hook 'c-mode-common-hook 'my-disable-electric-indentation)
====

First we defined a function that takes no arguments and calls (c-toggle-electric-state -1). Then we added the function to the c-mode-common-hook.

The -1 argument tells c-toggle-electric-state to disable, rather than toggle, the electric behavior (I learned this from C-h f c-toggle-electric-state; some functions might want nil, but this one wanted a negative number).

You could add an anonymous function to a hook directly:

[source, elisp]
(add-hook 'c-mode-common-hook
          (lambda () (c-toggle-electric-state -1)))
but then you have no way of referring to the function by name, so you can’t remove it from the hook with remove-hook.

=== The cc-mode style system

There is more to coding style than the size of indentation. Where should opening braces go? Should they be indented too?

The C-h v documentation for c-basic-offset mentioned a “style system”, and referred us to c-default-style.

TIP:
====
C-h v c-default-style
[source, elisp]
c-default-style is a variable defined in `cc-vars.el'.
Its value is ((java-mode . "java")
 (awk-mode . "awk")
 (other . "gnu"))
====

Elisp syntax for a list is (a b c), and for a pair is (a . b). Pairs are called “cons cells” in lisp terminology, and you access the first element with the function car, the second with the function cdr (pronounced “could-er”).

So the value of c-default-style is a list containing 3 pairs; it’s used as a lookup dictionary where java-mode, awk-mode and other are the keys, and "java", "awk" and "gnu" are the values (in this case, names of styles to use for each of the editing modes represented by the keys). These lookup dictionaries are called “alists”.

TIP: C-h S alist

In your init file you could set c-default-style so that the default style for other[4] is something other than "gnu".

If you need to customize anything (including c-basic-offset and indent-tabs-mode) to something different than any of the built-in styles, I recommend you define your own style: Thus if you work on different projects with different styles, you will be able to switch easily (with c-set-style). The way we set c-basic-offset earlier will automatically create a style called “user”.

For help see “Configuration basics”, “Customizing indentation”, and “Sample .emacs file” in the CC Mode Manual.

=== Binding keys

I often come across source code where one file expects tabs to equal 8 spaces, and another file in the same directory—or even other lines within the same file—want a tab to be 4 spaces. Let’s create a function that cycles tab-width between 2, 4 and 8 spaces.

(I found the variable tab-width by using apropos-variable to search for “tab”.)

TIP:
====
[source, elisp]
(defun my-tab-width ()
  "Cycle tab-width between values 2, 4, and 8."
  (interactive)
  (setq tab-width
        (cond ((eq tab-width 8) 2)
              ((eq tab-width 2) 4)
              (t 8)))
  (redraw-display))
====

The cond expression evaluates to 2 if tab-width equals 8; to 4 if tab-width equals 2; and to 8 otherwise. Look up cond and eq in the Info manuals if you like.

I’ve been naming all my functions “my-something” because elisp doesn’t have separate namespaces for each mode or package; this way I can be sure my functions won’t accidentally re-define an existing function that some editing mode relies on.

Now let’s bind our new function to a key sequence, so we can invoke it conveniently. C-c followed by a letter is reserved for users to define, so we’ll use C-c t:

TIP:
====
[source, elisp]
(global-set-key (kbd "C-c t") 'my-tab-width)
====

The meaning of “global” in global-set-key should be obvious. If you’d like a keybinding just for cc-mode, use define-key to add the binding to the mode’s keymap:

[source, elisp]
(define-key c-mode-base-map (kbd "C-c t") 'my-tab-width)

I discovered c-mode-base-map with C-h v c-mode- TAB TAB. There is also a c-mode-map which is just for the C language, rather than all languages supported by cc-mode.

=== Associating file extensions with an editing mode

Say you want .h files to open in c++-mode rather than c-mode:

TIP:
====
C-h v auto-mode-alist

C-h f add-to-list
====

The trickiest part will be getting the regular expression right—elisp doesn’t have syntax for a regexp literal, so you have to put it inside a string, and then the string backslash-escaping makes the regexp rather awful. See “Regexps” in the Emacs manual.

=== Homework

If you have a spare 30 minutes read Steve Yegge’s Emergency Elisp.
如果你有 30 分钟时间, 阅读 Steve Yegge 的 Emergency Elisp.

如果你有 6 个月的时间来完成计算机程序的结构与解释, 一个 MIT 的有名的课本教授了重要的(也很先进)的编程概念和技术使用一个简单的 Lisp 方言叫做 Scheme.
如果你喜欢数学方面的东西比如用埃拉托斯特尼筛法来找出素数, 海伦的方法来计算平方根, 或者蒙特卡罗模拟法来估算 pi 值, 那你会爱上这本书的.

如果你在阅读本手册之前在网上有一大堆的 .emacs 自定义配置, 试着去彻底的理解它们.

将来, 当你需要一个特定的自定义选项, 试着去发现解决方案从手册或者 elisp 的源码在用谷歌搜索之前.

不要尝试去修改 Emacs 发行版自带的 elisp 文件.
第一, 要合并你的改变到一个新的 Emacs 版本并不容易.
第二, 文件是被编译过的, 所以你需要重新编译它们.
第三, 就算你这样做了也没什么用因为核心的 elisp 函数都是被内置在 Emacs 的镜像中的,
所以你不得不重新编译整个程序.
你应该做的, 是使用变量和钩子来提供自定义配置.

不要把注意力放在 Emacs 的手册上当它告诉你去使用 'Easy customization' 这个功能时(在一些帮助缓冲区中它会说“you can customize this variable”).
它指向一个非常糟糕的半图形化界面来设置 Emacs 的变量. 最好保持你所有的自定义配置在你的 init 文件中.
